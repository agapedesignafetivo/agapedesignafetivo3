<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>Feito por Criis</title>

<style>
  html, body {
    margin:0;
    padding:0;
    overflow:hidden;
    background:black;
    height:100%;
    width:100%;
  }

  #camera-wrap {
    position:fixed;
    inset:0;
    width:100vw;
    height:100vh;
    overflow:hidden;
    background:black;
  }

  video {
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    object-fit:cover;
    background:black;
  }

  #frame {
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    pointer-events:none;
  }

  #buttons {
    position:fixed;
    bottom:25px;
    width:100%;
    display:flex;
    justify-content:center;
    gap:20px;
    z-index:20;
  }

  button {
    padding:6px 12px;
    border:3px solid #74a14a; /* Borda verde */
    border-radius:12px;
    font-size:14px;
    font-weight:bold;
    background:#ffffff;
    cursor:pointer;
  }

  #download { display:none; }

  /* Indicador REC com piscando */
  #recordingIndicator {
    position:fixed;
    top:20px;
    left:50%;
    transform:translateX(-50%);
    background:rgba(0,0,0,0.7);
    color:#fff;
    padding:6px 14px;
    font-size:16px;
    font-weight:bold;
    border-radius:20px;
    display:none;
    z-index:30;
  }

  #recordingIndicator.blink::before {
    content: "üî¥";
    display:inline-block;
    margin-right:6px;
    animation: blink 1s infinite;
  }

  @keyframes blink {
    0%, 50%, 100% { opacity: 1; }
    25%, 75% { opacity: 0; }
  }
</style>
</head>
<body>

<div id="camera-wrap">
  <video id="video" autoplay playsinline muted></video>
  <img id="frame" src="moldura.png">
</div>

<div id="recordingIndicator">00:00</div>

<div id="buttons">
  <button id="switchBtn">üîÑ Trocar C√¢mera</button>
  <button id="snapBtn">üì∏ Tirar Foto</button>
  <button id="recordBtn">üé• Gravar V√≠deo</button>
  <button id="stopBtn" style="display:none;">‚èπÔ∏è Parar Grava√ß√£o</button>
</div>

<a id="download" download="foto-evento.png"></a>

<canvas id="recordCanvas" style="display:none;"></canvas>

<script>
const video = document.getElementById("video");
const frame = document.getElementById("frame");
const snapBtn = document.getElementById("snapBtn");
const switchBtn = document.getElementById("switchBtn");
const download = document.getElementById("download");
const recordBtn = document.getElementById("recordBtn");
const stopBtn = document.getElementById("stopBtn");
const recordCanvas = document.getElementById("recordCanvas");
const recordingIndicator = document.getElementById("recordingIndicator");

let stream = null;
let usingFront = true;
let mediaRecorder = null;
let recordedChunks = [];
let isRecording = false;
let recordStartTime = 0;
let recordTimerInterval = null;

const API_URL = "https://videos-molduras-production-00e9.up.railway.app/convert";
const isiOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

/* ---------------------
   INICIAR C√ÇMERA
---------------------- */
async function startCamera(){
  if(stream) stream.getTracks().forEach(t=>t.stop());

  stream = await navigator.mediaDevices.getUserMedia({
    video:{ facingMode: usingFront ? "user" : "environment" },
    audio:true
  });

  video.srcObject = stream;
  video.style.transform = usingFront ? "scaleX(-1)" : "scaleX(1)";
  await waitForVideoReady();
}

function waitForVideoReady(){
  return new Promise(resolve=>{
    if(video.readyState >= 2 && video.videoWidth > 0) resolve();
    else video.onloadedmetadata = ()=>resolve();
  });
}

switchBtn.onclick = () => {
  usingFront = !usingFront;
  startCamera();
};

/* ---------------------
   FOTO 1080x1920
---------------------- */
snapBtn.onclick = async () => {
  await waitForVideoReady();

  const targetW = 1080;
  const targetH = 1920;
  const canvas = document.createElement("canvas");
  canvas.width = targetW;
  canvas.height = targetH;
  const ctx = canvas.getContext("2d");

  const vw = video.videoWidth;
  const vh = video.videoHeight;

  const videoRatio = vw / vh;
  const targetRatio = targetW / targetH;

  let sx, sy, sw, sh;
  if(videoRatio > targetRatio){
    sh = vh;
    sw = sh * targetRatio;
    sx = (vw - sw)/2;
    sy = 0;
  } else {
    sw = vw;
    sh = sw / targetRatio;
    sx = 0;
    sy = (vh - sh)/2;
  }

  ctx.save();
  if(usingFront){
    ctx.translate(targetW,0);
    ctx.scale(-1,1);
  }

  ctx.drawImage(video,sx,sy,sw,sh,0,0,targetW,targetH);
  ctx.restore();

  ctx.drawImage(frame,0,0,targetW,targetH);

  download.href = canvas.toDataURL("image/png");
  download.click();
};

/* ---------------------
   TIMER REC
---------------------- */
function startTimer(){
  recordStartTime = Date.now();
  recordingIndicator.style.display = "block";
  recordingIndicator.classList.add("blink");

  recordTimerInterval = setInterval(()=>{
    const diff = Math.floor((Date.now() - recordStartTime)/1000);
    const m = String(Math.floor(diff/60)).padStart(2,"0");
    const s = String(diff%60).padStart(2,"0");
    recordingIndicator.textContent = `${m}:${s}`;
  },500);
}

function stopTimer(){
  clearInterval(recordTimerInterval);
  recordingIndicator.style.display = "none";
  recordingIndicator.classList.remove("blink");
}

/* ---------------------
   GRAVAR V√çDEO 1080x1920
---------------------- */
recordBtn.onclick = async () => {
  if(isRecording) return;
  isRecording = true;
  recordedChunks = [];

  await waitForVideoReady();

  const targetW = 1080;
  const targetH = 1920;
  recordCanvas.width = targetW;
  recordCanvas.height = targetH;
  const ctx = recordCanvas.getContext("2d");

  function draw(){
    if(!isRecording) return;

    ctx.clearRect(0,0,targetW,targetH);

    ctx.save();
    if(usingFront){
      ctx.translate(targetW,0);
      ctx.scale(-1,1);
    }

    const videoRatio = video.videoWidth/video.videoHeight;
    const targetRatio = targetW/targetH;

    let sx, sy, sw, sh;
    if(videoRatio>targetRatio){
      sh = video.videoHeight;
      sw = sh*targetRatio;
      sx = (video.videoWidth - sw)/2;
      sy = 0;
    } else {
      sw = video.videoWidth;
      sh = sw/targetRatio;
      sx = 0;
      sy = (video.videoHeight - sh)/2;
    }

    ctx.drawImage(video,sx,sy,sw,sh,0,0,targetW,targetH);
    ctx.restore();

    ctx.drawImage(frame,0,0,targetW,targetH);

    requestAnimationFrame(draw);
  }
  draw();

  const canvasStream = recordCanvas.captureStream(24);
  const audioTrack = stream.getAudioTracks()[0];
  const combined = new MediaStream();
  canvasStream.getVideoTracks().forEach(t=>combined.addTrack(t));
  if(audioTrack) combined.addTrack(audioTrack);

  mediaRecorder = new MediaRecorder(combined,{ mimeType:"video/webm" });

  mediaRecorder.ondataavailable = e => {
    if(e.data.size>0) recordedChunks.push(e.data);
  };

  mediaRecorder.onstop = async () => {
    isRecording = false;
    stopTimer();

    recordingIndicator.style.display = "block";
    recordingIndicator.textContent = "‚è≥ Processando v√≠deo...";

    const blob = new Blob(recordedChunks,{ type:"video/webm" });
    const fd = new FormData();
    fd.append("video", blob, "video.webm");

    try {
      const device = isiOS ? "ios" : "android";
      const res = await fetch(`${API_URL}?device=${device}`,{
        method:"POST",
        body: fd
      });

      const mp4 = await res.blob();
      const url = URL.createObjectURL(mp4);

      const a = document.createElement("a");
      a.href = url;
      a.download = "video-moldura.mp4";
      a.click();

      URL.revokeObjectURL(url);
      recordingIndicator.style.display = "none";

    } catch(err){
      console.error("Erro na convers√£o:",err);
      recordingIndicator.textContent = "‚ùå Erro ao processar v√≠deo!";
      setTimeout(()=>recordingIndicator.style.display="none",2000);
    }
  };

  mediaRecorder.start(100);
  startTimer();
  recordBtn.style.display = "none";
  stopBtn.style.display = "inline-block";
};

/* ---------------------
   PARAR
---------------------- */
stopBtn.onclick = () => {
  if(mediaRecorder && mediaRecorder.state==="recording"){
    isRecording = false;
    mediaRecorder.stop();
  }

  recordBtn.style.display = "inline-block";
  stopBtn.style.display = "none";
};

startCamera();
</script>

</body>
</html>
