<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title></title>

<style>
  html, body {
    margin:0;
    padding:0;
    overflow:hidden;
    background:black;
    height:100%;
    width:100%;
  }

  #camera-wrap {
    position:fixed;
    inset:0;
    width:100vw;
    height:100vh;
    overflow:hidden;
    background:black;
  }

  video {
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    object-fit:cover;
    background:black;
  }

  #frame {
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    pointer-events:none;
  }

  #buttons {
    position:fixed;
    bottom:25px;
    width:100%;
    display:flex;
    justify-content:center;
    gap:20px;
    z-index:20;
  }

  button {
    padding:12px 20px;
    border:0;
    border-radius:12px;
    font-size:18px;
    font-weight:bold;
    background:#ffffffd0;
    cursor:pointer;
  }

  #download { display:none; }

  /* ðŸ‘‡ Indicador REC */
  #recordingIndicator {
    position:fixed;
    top:20px;
    left:50%;
    transform:translateX(-50%);
    background:rgba(0,0,0,0.7);
    color:#fff;
    padding:6px 14px;
    font-size:16px;
    font-weight:bold;
    border-radius:20px;
    display:none;
    z-index:30;
  }
</style>
</head>
<body>

<div id="camera-wrap">
  <video id="video" autoplay playsinline muted></video>
  <img id="frame" src="moldura.png">
</div>

<div id="recordingIndicator">ðŸ”´ REC 00:00</div>

<div id="buttons">
  <button id="switchBtn">Trocar</button>
  <button id="snapBtn">Foto</button>
  <button id="recordBtn">Gravar</button>
  <button id="stopBtn" style="display:none;">Parar</button>
</div>

<a id="download" download="foto-evento.png"></a>

<!-- Canvas para gravaÃ§Ã£o -->
<canvas id="recordCanvas" style="display:none;"></canvas>

<script>
/* ---------------------
   ELEMENTOS
---------------------- */
const video = document.getElementById("video");
const frame = document.getElementById("frame");
const snapBtn = document.getElementById("snapBtn");
const switchBtn = document.getElementById("switchBtn");
const download = document.getElementById("download");

const recordBtn = document.getElementById("recordBtn");
const stopBtn = document.getElementById("stopBtn");
const recordCanvas = document.getElementById("recordCanvas");
const recordingIndicator = document.getElementById("recordingIndicator");

/* ---------------------
   VARIÃVEIS
---------------------- */
let stream = null;
let usingFront = true;

let mediaRecorder = null;
let recordedChunks = [];
let isRecording = false;

let recordStartTime = 0;
let recordTimerInterval = null;

let lastVideoUrl = null;

const API_URL = "https://video-converter-api-production-bb8e.up.railway.app/convert";
const isiOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

/* ---------------------
   INICIAR CÃ‚MERA
---------------------- */
async function startCamera(){
  if(stream){
    stream.getTracks().forEach(t=>t.stop());
  }

  stream = await navigator.mediaDevices.getUserMedia({
    video:{ facingMode: usingFront ? "user" : "environment" },
    audio:true
  });

  video.srcObject = stream;

  video.style.transform = usingFront ? "scaleX(-1)" : "scaleX(1)";
  await waitForVideoReady();
}

function waitForVideoReady(){
  return new Promise(resolve=>{
    if(video.readyState >= 2 && video.videoWidth > 0){
      resolve();
      return;
    }
    video.onloadedmetadata = ()=>resolve();
  });
}

switchBtn.onclick = () => {
  usingFront = !usingFront;
  startCamera();
};

/* ---------------------
   FOTO
---------------------- */
snapBtn.onclick = async () => {
  await waitForVideoReady();

  const vw = video.videoWidth;
  const vh = video.videoHeight;

  const targetW = 720;
  const targetH = 1280;

  const canvas = document.createElement("canvas");
  canvas.width = targetW;
  canvas.height = targetH;
  const ctx = canvas.getContext("2d");

  const buffer = document.createElement("canvas");
  buffer.width = targetW;
  buffer.height = targetH;
  const btx = buffer.getContext("2d");

  btx.save();
  if(usingFront){
    btx.translate(targetW,0);
    btx.scale(-1,1);
  }

  const videoRatio = vw / vh;
  const targetRatio = targetW / targetH;

  let sx, sy, sw, sh;

  if(videoRatio > targetRatio){
    sh = vh;
    sw = sh * targetRatio;
    sx = (vw - sw) / 2;
    sy = 0;
  } else {
    sw = vw;
    sh = sw / targetRatio;
    sx = 0;
    sy = (vh - sh) / 2;
  }

  btx.drawImage(video, sx, sy, sw, sh, 0, 0, targetW, targetH);
  btx.restore();

  ctx.drawImage(buffer, 0, 0);
  ctx.drawImage(frame, 0, 0, targetW, targetH);

  download.href = canvas.toDataURL("image/png");
  download.click();
};

/* ---------------------
   TIMER REC
---------------------- */
function startTimer(){
  recordStartTime = Date.now();
  recordingIndicator.style.display = "block";

  recordTimerInterval = setInterval(()=>{
    const diff = Math.floor((Date.now() - recordStartTime) / 1000);
    const m = String(Math.floor(diff / 60)).padStart(2,"0");
    const s = String(diff % 60).padStart(2,"0");
    recordingIndicator.textContent = `ðŸ”´ REC ${m}:${s}`;
  },500);
}

function stopTimer(){
  clearInterval(recordTimerInterval);
  recordingIndicator.style.display = "none";
}

/* ---------------------
   GRAVAR VÃDEO
---------------------- */
recordBtn.onclick = async () => {
  if(isRecording) return;

  isRecording = true;
  recordedChunks = [];

  await waitForVideoReady();

  const vw = video.videoWidth;
  const vh = video.videoHeight;

  const targetW = 720;
  const targetH = Math.round(targetW * (vh / vw));

  recordCanvas.width = targetW;
  recordCanvas.height = targetH;
  const ctx = recordCanvas.getContext("2d");

  function draw() {
    if(!isRecording) return;

    ctx.clearRect(0,0,targetW,targetH);

    ctx.save();
    if(usingFront){
      ctx.translate(targetW,0);
      ctx.scale(-1,1);
    }

    ctx.drawImage(video, 0, 0, targetW, targetH);
    ctx.restore();

    ctx.drawImage(frame,0,0,targetW,targetH);

    requestAnimationFrame(draw);
  }
  draw();

  const canvasStream = recordCanvas.captureStream(24);
  const audioTrack = stream.getAudioTracks()[0];

  const combined = new MediaStream();
  canvasStream.getVideoTracks().forEach(t=>combined.addTrack(t));
  if(audioTrack) combined.addTrack(audioTrack);

  mediaRecorder = new MediaRecorder(combined, { mimeType:"video/webm" });

  mediaRecorder.ondataavailable = e => {
    if(e.data.size > 0) recordedChunks.push(e.data);
  };

  mediaRecorder.onstop = async () => {
    isRecording = false;
    stopTimer();

    const blob = new Blob(recordedChunks, { type:"video/webm" });

    // enviar para conversÃ£o
    const fd = new FormData();
    fd.append("video", blob, "video.webm");

    const device = isiOS ? "ios" : "android";

    const res = await fetch(`${API_URL}?device=${device}`, {
      method:"POST",
      body:fd
    });

    const mp4 = await res.blob();
    const url = URL.createObjectURL(mp4);

    const a = document.createElement("a");
    a.href = url;
    a.download = "video-moldura.mp4";
    a.click();

    URL.revokeObjectURL(url);
  };

  mediaRecorder.start(100);

  startTimer();
  recordBtn.style.display = "none";
  stopBtn.style.display = "inline-block";
};

/* ---------------------
   PARAR
---------------------- */
stopBtn.onclick = () => {
  if(mediaRecorder && mediaRecorder.state === "recording"){
    isRecording = false;
    mediaRecorder.stop();
  }

  recordBtn.style.display = "inline-block";
  stopBtn.style.display = "none";
};

startCamera();
</script>

</body>
</html>
